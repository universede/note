---
title: "Soft Design"
date: 2020-05-10T21:34:16+08:00
draft: false
categories: ["Design Pattern"]
tags: ["Design Pattern"]
---

### 软件体系结构

* 软件体系结构产生原因  
    软件体系结构产生的原因是软件危机的出现。
*  软件危机的表现  
    1.软件成本日益增长  
    2.开发进度难以控制  
    3.软件质量差  
    4.软件维护困难  
    软件危机的原因  
    1.用户需求不明确  
    2.缺乏正确的理论指导  
    3.软件规模原来越大  
    4.软件复杂度越来越高  
* 克服软件危机  
    主要从两方面入手，即技术和管理。

### 设计模式简要

* 软件设计模式的分类  
    1.创建型：类与实例化时使用的模式  
    2.结构型：描述类与对象怎样结合  
    3.行为型：设计到算法和对象职责间的分配  

|	创建 	| 结构 	| 行为    |
|   :-:     |  :-:  |  :-:    |
|　类 工厂方法| 适配器| 解释器模板方法|
|对象 抽象方法| 桥接 |	责任链　命令|
|	生成器| 	 组成 |	迭代器 中介者|
|	原型 |	 装饰 |	备忘录 观察者|
|	单例 |	享元 代理| 状态 策略 访问者|

### 七大原则[^1]

* 单一职责原则  
    Simgle Responsibility Principle:一个类只负责一个功能领域中的相应职能。  
    它是最简单的面向对象设计原则，用于控制类的粒子大小。同时告诉我们，一个 类不能太“累”！对于一个软件系统，一个类承担的职责越多，则复用性就越低，所 以在进行设计时把相似的职责封装在一起，对于其他的放在另一个类中，使其之间的 耦合性降低。  

* 开－闭原则  
    OPen-Closed Principle:软件实体应对扩展开放，而对修改关闭。即软件实体应尽量在不修改原有代码 的情况下进行扩展。  
    在开闭原则的定义中，软件实体可以指一个软件模块、一个或多个类组成的局部结构或一 个独立的类。  
    在软件产品中，需求会随时间的变动而变动。这也就引进了开闭的原则，需要对系统进行抽 象化设计，抽象化是开闭原则的关键。  

* 里氏代换原则  
    Liskov Substitution Principle:所有引用基类对象的地方能够透明地使用其子类的对象。  
    它告诉我们，在软件中一个基类对象替换成它的子类对象，程序将不会产生任何的错误和 异常，反之，则不成立。  
    里氏替换原则是实现开闭原则的重要方式之一，由于基类对象的地方都可以使用子类对象， 因此在程序中尽量使用基类对象来对对象进行定义，而在运行是在确定其子类类型，用子类对 象来替换父类对象。  
    注意问题:  
    a.子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。  
    b.在使用里氏替换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现其父 接口，并实现在父类中声明的方法，运行时，子类替换父类实例，我们可以很方便地扩展系统的 功能，同时无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。  
    c.Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏替换原则，这是一个 是实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。  

* 依赖倒转原则  
    Dependence Inversion Principle:抽象不应该依赖细节，细节应该依赖于抽象。换言之，主要针对接口编程，而不是 针对实现编程。  
    依赖倒转原则要求我们在程序中传递参数时或在关联关系中，尽量使用层次高的抽象层类，即 使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等， 而不是用具体的类来来做这些事。为了确保该原则的应用，一个具体的类应当只实现接口或抽象类 中声明过的方法，而不要给出多余的方法，否则将无法调用到子类中增加的新方法。  
    引入抽象层后，系统的灵活性将会提高，而在程序中应尽量使用抽象层进行编程，而把具体类 写在配置文件里。这样一来，如果系统发生变化，只需对抽象层进行编程，对配置文件进行修改， 而不需要对原来的代码进行修改，这就符合开闭原则。  
    在实现依赖倒转原则的时，我们针对抽象层进行编程，而将具体类的对象通过依赖注入的方式注 入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的 对象。而常用的注入方式有三种：构造注入、设值注入和接口注入。构造注入：通过构造函数 来传入具体类的对象；设值注入：通过Setter方法来传入具体类的对象；接口注入：通 过再接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的抽象类型，在运行时再传 入具体类型的对象，由子类对象来覆盖父类对象，这是用来里氏替换原则。通过依赖倒转原则，可以 看出开闭原则和里氏替换原则的三者间的共同运用。  

* 接口隔离原则  
    Interface Segregation Principle:使用多个专门的接口，而不使用单一的总接口。  
    根据接口隔离原则，一个接口的过大时，我们需要对其接口进行分割成一些更小的接口，使用该接 口的客户端仅需知道与之相关的方法即可。理应每个接口承担一个相对独立的角色，干自己理应干的事。 在这里的“接口”有两种含义：一种是指一个类型所具有的方法特征的集合，仅仅是逻辑上的抽象；而另 一种是指某中语言具体的“接口”的定义，有严格的定义和结构，如java中的interface。  

* 迪米特原则  
    Low of Demeter Principle:又称最少知识原则，一个软件实体应当尽可能地与其他实体发生相互作用。  
    如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少的影响其他模块，扩 展相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制实体之间通信的宽度和深度。  
    迪米特法则自身包含了几个形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等。在迪米特 法则中，对于一个对象，他的朋友包括：１).当前对象本身–this；２).以参数形式传入到当前对象方法 中的对象；3).当前对象的成员对象；4).如果当前对象的成员对象是一个集合，那么集合中的元素也都是 朋友；5).当前对象所创建的对象。  

* 组合/聚合原则  
    Composition Reuse Pribciple:尽量使用对象组合，而不是继承来达到复用的目的。  
    组合、聚合原则就是在一个新的对象里通过关联关系来使用一些已有的对象，使之成为新对象的一 部分；新对象通过委派调用已有对象的方法达到复用功能的目的。  
    在《java编程思想》里的“重复运用实现码”里提到了一点，“把某个class对象置于另一个class内， 我们称这种形式为'产生一个成员对象‘。新的classes可有任意数目，任意型别的它种对象组成，这些 对象可以任意组合方式到你想要的功能。隐喻这种方法是’以既有的classes合成新的class‘，所以这种 观念被称为’组合‘或’聚合‘。组合通常被视为‘has-a’(拥有)的关系，就好像我们说’车子拥有引擎‘。” 在使用时通常声明为private。而“is-a”(是一种),即一个类是另一个类的“一种”。  
    
## 设计模式[^2]
   &emsp;设计模式中主要分为三大类，其中6种创建型设计模式，7种结构性设计模式，11种行为型设计模式
   
#### 创建型模式
* 简单工厂模式
  &emsp;更多的是在接口与实现的层面上，即一个接口```Person```类，然后有一个```Student```类和```Teacher```类，获取相关的对象：
  ```
  Person student = new Student();
  Person teacher = new Teacher();
  ```
----
* 工厂方法模式(虚拟构造器函数、Virtual Constructor、Factory Method)
&emsp;
----
* 抽象工厂方式模式
&emsp;
----
* 建造者模式(生成器模式)

----
* 原型模式

----
* 单例模式


#### 结构性模式
* 适配器模式

----
* 桥接模式

----
* 组合模式

----
* 装饰模式

----
* 外观模式
   类似于中介者模式,但有别于中介者模式,它更多是对外提供的一个处理逻辑的地方.如,一个富豪现在需要开一个公司,但又不想自己去办理证件,于是把相关的信息委托给一个手下,手下拿着这些证件到相关部门办理.这里,**相关部门**就是一个对外提供的外观,外人通过识别这个外观,可以办理相关的业务.这里的**手下**只是代理去办业务,但并不是真正实现业务的办理.
  
----
* 享元模式
   用途： 允许消耗少量的内存，支持大量的相似的对象
   识别方式： **通过构建方法来识别，它会返回缓存对象而不是创建对象**
----
* 代理模式

#### 行为性模式
* 责任连模式

----
* 命令模式

----
* 解释器模式

----
* 迭代器模式
  可以通过**导航方法**(例如：**previous**或**next**等)来识别，更多的像是把集合数据与迭代数据的过程分离
----
* 中介者模式
  故名之意,把一件事委托给另一个人帮你完成,自己直接获取结果.如,我现在要买一座房子,但又没有时间去排队摇号,于是,我就委托给中介去帮我完成,完成后中介直接给我一个结果.

----
* 备忘录模式

----
* 观察者模式

----
* 状态模式

----
* 策略模式
   更多的是解决一件事,可以有多种方式,只是实现的方式有所不同.如,现在要去机场,可以通过多种方式到达机场,如,走路、打出租车
   坐地铁、作自行车等.

----
* 模板方法模式
  - 定义
    定义了一个操作中的算法骨架,而将算法的一些步骤延迟到子类中,使得子类可以不改变该算法结构的情况下重定义该算法的某些步骤.
  - 优点  
    1. 封装不变部分,扩展可变部分
    2. 在父类中提取公共操作,提高复用性
    3. 部分方法由子类实现,通过扩展方式增加相应的功能,符合开闭原则
  - 缺点
    a. 对不同的实现增加子类,导致类的增加,系统变得庞大,设计需更加抽象,增加了复杂性
    b. 父类中的抽象方法由子类实现,子类执行的结果会影响父类的结,这导致一种反向的控制结构,提高代码阅读难度
    c. 继承存在一定的缺陷,父类添加新的抽象方法,子类需要进行重写
  - 例子
    MyBatis中的BaseExecute类就是使用的模板方法,通过实现Executor接口,实现公共代码,具体实现由子类完成
    ```java
    public abstract class BaseExecutor implements Executor { 
        ...
        protected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException;

        protected abstract List<BatchResult> doFlushStatements(boolean isRollback) throws SQLException;

        protected abstract <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)
            throws SQLException;

        protected abstract <E> Cursor<E> doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)
            throws SQLException;
        ...    
    }
    public class SimpleExecutor extends BaseExecutor { ... }
    ```
----
* 访问者模式

REFERENCE

[^1]: java设计模式(选用教材简易版)
[^2]:https://refactoringguru.cn/design-patterns/factory-method
