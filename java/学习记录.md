# 学习记录

## 软件架构^[https://developer.aliyun.com/article/930304] 
* laas
基础设施即服务
概念：需要帮助客户搭建好运行服务的基础设施，就是在线下筹备机房或机器，组成环境运行能够提供服务的项目并部署该项目提供服务。
举例：举例说就是我要在提供服务之前给客户那边搭建好线下的运行环境，比如在高校的校园中选择一个房间作为机房，在准备电脑进行组网，将项目运行在搭建好的机器上面就可以进行服务的访问。

* paas 
平台即服务
概念：利用云端搭建好操作系统或软件层面的如数据库、中间件等供用户使用，使得用户无需关注底层的基础设施和运行环境，只需要利用这些环境运行自己的应用和数据。
举例：就好比学校要使用我的就业管理系统进行管理，但是不想自己搭建机房和环境，所以就直接本地用少量的机器搭建客户端，将数据库、中间件或部分接口放在云端，请求时直接请求云端的接口和数据。

* saas
软件即服务
概念：即云端已经将操作系统到运行环境到软件的客户端都已经搭建好了，使用方不需要安装任何环境或软件，只需要访问客户端就能直接使用、
举例：类似于在我的毕业生管理系统上，我先自己利用云端搭建好平台，然后如果有学校想要使用的话直接分配给他们一些账号和密码，他们就可以直接访问我搭建好的系统进行操作了。

## 分布式架构、微服务架构(MSA)
* 分布式
将一个大型的系统拆分成多个独立的子系统，这些子系统分布在不同的服务器或节点上，通过网络进行通信和协作，以完成整个系统的功能。
* 微服务
 将一个大型的应用拆分成多个小型的、独立的服务，每个服务都可以独立部署、扩展和维护。

## 分布式事务
### 由来
1. 单体项目
一个模块对应一个数据库中的多张表
采用本地**@Transactional**即可解决
2. 分布式项目1
多个模块对应一个数据库中的多个表
采用消息中间件即可解决
3. 分布式项目2
多个模块对应多个数据库中的多个表
采用消息中间件和Seata都可，偷懒使用Seata，自己实现可以使用消息中间件
注：seata是开源的分布式事务解决方案，力于提供高性能和简单易用的分布式事务服务。为用户提供了AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。

### 属性
原子性、一致性、隔离性、持久性，即ACID
原子性：一个事务中的所有操作，要么全部成功，要么全部失败。
一致性：在事务开始前，进行时，结束后，数据库的完整性没有得到破坏。
隔离性：数据库允许多个并发事务同时对数据进行读写和修改的能力。
持久性：事务处理结束后，对数据的修改是永久性的，即使系统故障也不会丢失。

### 分布式事务^[https://segmentfault.com/a/1190000040321750#item-2-5]
不同的服务之间通过网络协调完成的事务（由于数据库资源分布在不同的服务器上，可能由不同的事务管理器管理）。
解决方案：
1. 两阶段提交(2PC)/XA、三阶段提交(3PC)
XA事务组成：
多个资源管理器(RM)+一个事务管理器(TM)+应用程序(AP)
第一阶段（prepare）： 所有的参与者(RM)准备执行事务并锁住需要的资源。参与者ready时，向TM报告已准备就绪。
第二阶段（commit/rollback）：当事务管理器(TM)确认所有的参与者(RM)都ready后，向所有参与者发送commit命令。如果任何一个参与者prepare后，TM会通过所有完成的prepare的参与者进行回滚。
特点：
（1）简单易理解
（2）锁住资源时间过程，并发度低。
2. Sage
将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。
3. TCC
Try - Confirm - Cancel
三阶段：
try阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）
confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作要求具备幂等设计，Confirm 失败后需要进行重试。
cancel阶段：取消执行，释放 Try 阶段预留的业务资源。
Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致，要求满足幂等设计。
特点：
（1）并大量较高，无长期资源锁定
（2）开发量较大，需要提供try/confirm/cancel接口
（3） 一致性较好，不会发生SAGE已扣款最后转账失败的情况
（4）适用性订单类业务，对中间状态有约束的业务
4. 本地消息表
通过消息的方式来异步确保执行。
写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么他们全都成功，要么全都失败。
流程：
创建本地消息表，并轮询消息。
特点：
（1）不支持回滚
（2）轮询生产消息难实现，如果定时轮询会延长事务总时长，如果订阅binlog则开发维护困难
场景：
可异步执行的业务，且后续操作无需回滚的业务
容错机制：
（1）上一个操作事务失败，事务直接回滚，无后续步骤
（2）轮序生产消息失败，下一个操作事务失败都会进行重试
5. 事务消息
实际就是把本地消息表的实现方式，通过使用MQ的方式来实现消费，减少了创建本地消息表和轮询的流程，如rocketmq
解决了生产端的消息发送与本地事务执行的原子性问题。
发送与提交：
（1）发送消息（half消息）
（2）服务端存储消息，并响应消息的写入结果
（3）根据发送消息执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）
（4）根据本地事务状态执行commit/rollback（Commit操作发布消息，消息对消费者可见）
补偿流程：
对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”Producer收到回查消息，返回消息对应的本地事务的状态，为Commit或者Rollback事务消息方案与本地消息表机制非常类似，区别主要在于原先相关的本地表操作替换成了一个反查接口
特点：
（1）长事务仅需要分拆多个任务，并提供一个反查接口，使用简单
（2）事务消息的回查没有好的方案，极端情况可能存在数据错误
场景：
可异步执行的业务，且后续操作无需回滚的业务
6. 最大努力通知
发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。
解决方案：
（1）提供接口，让接受通知方能够通过接口查询业务处理结果
（2）消息队列ACK机制，消息队列按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。之后不再通知
场景：
适用于业务通知类型，微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口
7. AT事务模式

### 分布式锁^[https://www.cnblogs.com/liuqingzheng/p/11080501.html]
是一种机制，用于在分布式系统中保证多个进程或线程在访问共享资源时不会发生冲突，从而保证数据的一致性和系统的稳定性。
实现方式：
1. 基于数据库的分布式锁
如mysql，利用数据库的唯一约束或行锁定机制实现。
2. 基于缓存的分布式锁
利用缓存系统(如redis)来实现原子操作
3. 基于ZooKeeper的分布式锁
利用ZooKeeper的临时顺序节点和监听机制来实现

## 中间件
### MongoDB^[https://www.runoob.com/mongodb/mongodb-tutorial.html]
开源**文档型数据库**,类似JSON 的文档模型存储数据
基于文档的 NoSQL 数据库
旨在为 WEB 应用提供可扩展的高性能数据存储解决方案
介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。

### Elasticsearch^[https://elasticsearch.bookhub.tech/intro/]
* 概念
1. 是分布式搜索和分析引擎
2. 分布式文档存储(相当于数据库)
* 应用领域
1. 全文检索
2. 应用查询
3. 大数据领域
4. 日志检索
5. 监控领域
6. 机器学习

### MongoDB与Elasticsearch作为存储的区别
相同：
都有文档存储的功能
不同：
Elasticsearch更多是基于**查询搜索**的分析型数据库，MongoDB 定位于事务型应用层面 OLTP(在线事务处理)^[https://developer.aliyun.com/article/770889]

### ZooKeeper^[https://zookeeper.net.cn/] ^[https://zookeeper.net.cn/doc/r3.9.2/zookeeperOver.html]
开源的**分布式协调服务**。主要用于分布式应用程序。

### Mysql
#### 存储引擎
1. MyISAM
不支持事务，行级锁和外键约束
2. MyISAM Merge
把相同的MyISAM合并成一张虚表，主要用于日志和数据仓库
3. InnoDB
4. Memory
把数据存放内存中，主用于临时表中
5. archive
 只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面

### redis^[https://www.redis.net.cn/]
内存存储的数据结构服务器，可用于数据库、高速缓存和消息队列代理。

### ShardingSphere^[https://shardingsphere.apache.org/document/legacy/4.x/document/cn/overview/]
是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（计划中）这3款相互独立的产品组成。
均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。

### Memcached
是一个分布式内存对象缓存系统


## 多线程
### 锁机制^[https://blog.csdn.net/qq_34416331/article/details/107764522]
#### 锁分类
* 互斥锁
**只有一个线程能够访问被互斥锁保护的资源**
在访问共享对象之前，对其进行加锁操作。在访问完成之后进行解锁操作。加锁后，其他试图加锁的线程会被阻塞，知道当前线程解锁。解锁后，原本等待状态的线程变为就绪状态，重新竞争锁。
* 共享锁
允许多个线程共同访问资源
* 读写锁
既是互斥锁，又是共享锁。在**读模式下是共享锁，写模式下是互斥锁**。
#### 互斥锁
* Synchronized、Lock
1. synchronized 是 jvm 关键字，而 lock 是 java 类
2. synchronized 不用处理异常状态下的锁释放，**当资源使用完毕后或连接断开时自动释放锁**，而 Lock 需要**显示调用释放锁**
3. lock 接口提供了更多可适配的类和方法，包括非公平锁、读写锁等
4. 1.6版本后使用CSA算法，与lock性能差不多
* ReentrantLock 可重入锁
一种递归无阻塞的同步机制，也叫递归锁，指的是同一线程在外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。ReentrantLock 和 synchronized 都是可重入锁。
* 公平锁、非公平锁、中断锁
- 公平锁
公平锁即根据 FIFO 规则，从等待队列中取出第一个等待线程获取锁。
在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，如果是空，或者当前线程是等待队列的第一个，就占有锁，否则会将自己加入到等待队列中。
- 非公平锁
非公平锁下，新来的线程在一上来就会尝试直接占有锁，如果这时候刚好在发出请求时所变成可用状态，则这个锁会跳过队列中的等待线程，直接获得锁，否则，将自己加入到队列中。
可以通过 nonfairTruAcquire() 实现
- 可中断锁
即等待锁的过程是可以中断的，在互斥锁中，synchronized 是不可中断所，而 Lock 是可中断锁。
ReentrantLock 中提供了 tryLock 和 lockInterruptibly 两种方法来中断等待操作
tryLock:
```java
public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanoc(timeout));
}
```
可以通过设置超时时间 timeout 以及单位 unit，在等待指定时间后，若还没有获取锁，则中断锁。
```java
if(lock.tryLock()){//尝试获取锁
    try {
        // ... 获取锁后要做的内容
    } catch (Exception e) {
        throw new Exception(e);
    } finally {
        lock.unlock();
    }
}else{
    // 指定时间内没有获取到锁
}
```
lockInterruptibly:
```java
public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
}
```
lockInterruptibly 调用后，就会马上主动中断等待，并抛出 InterruptedException  异常。
```java
public class TestLockInterruptibly {
    public static void main(String[] args) {
        Service s = new Service();
        Runnable  r = new Runnable() {
           @override
            public void run() {
                s.serviceMethod();
            }
        }
        Thread t = new Thread(r);
        t.start();
        Thread.sleep(50);
        Thread t2 = new Thread(r);
        t2.start();
        Thread.sleep(50);
        t2.interrupt();  // 线程2中断
    }
}

public class Service {
    private Lock lock = new ReentrantLock();   // 定义锁对象
    public void serviceMethod() {
        try{ 
              lock.lockInterruptibly();  // 如果线程被中断了，不会获得锁，会产生异常
              System.out.println(Thread.currentThread().getName() + "-- begin lock");
              for(int i = 0; i < Integer.MAX_VALUE; i++) {
                new StringBuilder();
              }
              System.out.println( Thread.currentThread().getName() + " -- end lock");
         }catch(InterruptedException e) {
             System.out.println(Thread.currentThread().getName + "*** exp");
         } finally {
            System.out.println( Thread.currentThread().getName() + " ***** 释放锁");
            lock.unLock();    
        }
   }
}
```

#### 共享锁
共享锁是指一个锁可以被多个线程持有，获得读锁的线程只能够读数据，不能够写数据
共享锁则是 ReentrantReadWriteLock 的读锁

#### 独享锁
独享锁即互斥锁，一个锁只能被一个线程锁持有，若锁被持有，其他线程不能在获得这个锁。获得锁的线程能够进行读写
常见的独享锁如 synchronized、Lock、ReentrantReadWriteLock的写锁

#### 读写锁

#### 悲观锁、乐观锁
* 悲观锁
每一次去获取资源都认为会被修改，都需要加锁
场景：写多读少，在多写的情况下冲突经常发生，需要用锁来保证变量修改的有序性，如数据库中的行锁、表锁、读写锁等
实现方式：  synchronized 和 lock
* 乐观锁
每一次去获取资源否认为不会被修改，不加锁
但是更新数据的时候会去判断是否进行了修改操作，实现方式：数据库记录版本号等
场景：读多写少，即冲突很少发生的时候，省去了锁的开销，增大了吞吐量
实现方式：版本控制、CAS 算法


### 集合^[https://developer.aliyun.com/article/1400309]
* 多线程环境下使用ArrayList
1. 使用同步机制(synchronized 或者 ReentrantLock)
2. Collections.synchronizedList(new ArrayList)
标准类库中synchronizedList的关键操作都带有synchronized
3. 使用 CopyOnWriteArrayList
CopyOnWrite容器即写时复制的容器，简称“COW”，也叫做“写时拷贝”。如果针对arraylist进行读操作，不做任何额外操作。如果是写操作，会拷贝一份新的arraylist,针对新的进行修改，修改过程中如果有读操作，就继续使用旧的数据，修改完成后，就会使用新的替代（本质上是一个引用之间的赋值，是原子的）
优点：不需要加锁，不会有锁竞争，读多写少的场景下性能高
缺点：arraylist不能太大，否则占用内存太大，而且新写的数据不能第一时间读到。

## Spring
### spring、springmvc、springboot、springcloud^[https://cloud.tencent.com/developer/article/1516989]
* spring
是java企业级应用开发框架，包含了IOC、AOP、事务等
* springmvc
是spring框架中的一个模块，主要用于构建web应用
* springboot
是spring框架对springmvc进行的一个封装，旨在快速构建web开发流程
* springcloud
是一个工具包，旨在管理与协调各个服务

### IOC、DI、AOP

### SpringCloud事务
#### 声明式事务管理
使用@Transactional 注解
#### 分布式事务
* 使用场景
1. 多个模块操作同一个数据库中的多张表
2. 多个模块操作多个数据库中的多张表

## 设计模式

## 算法

## 运维


## 参考文献